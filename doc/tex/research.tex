\chapter{Исследовательский раздел}
\label{cha:research}

\section{Описание используемых шаблонов проектирования}

Для проведения исследования были выбраны следующие шаблоны проектирования:
\begin{itemize}
\item <<абстрактная фабрика>> --- предоставляет интерфейс для создания групп
связанных или зависимых объектов, не указывая их конкретный класс;
\item <<адаптер>> --- конвертирует интерфейс класса в другой интерфейс,
ожидаемый клиентом. Позволяет классам с разными интерфейсами работать вместе;
\item <<вызов переопределённого метода>> --- представляет ситуацию,
когда вызывается метод интерфейса,
для которого имеется реализация в производном классе.
Не является полноценным шаблоном проектирования, а скорее некоторым элементом.
Рассматривается, чтобы убедиться в возможности находить самые простые конструкции;
\item <<декоратор>> --- динамически предоставляет объекту дополнительные
возможности.
Представляет собой гибкую альтернативу наследованию для расширения
функциональности.
\item <<мост>> --- разделяет абстракцию и реализацию так,
чтобы они могли изменяться независимо.
\item <<посетитель>> --- представляет операцию, которая будет выполнена над
объектами группы классов.
Даёт возможность определить новую операцию без изменения кода классов,
над которыми эта операция производится.
\item <<хранитель>> --- не нарушая инкапсуляцияю, определяет и сохраняет
состояние объекта и позволяет восстановить объект в этом состоянии.
\item <<цепочка ответственности>> --- избегает связывания отправителя запроса с
его получателем, давая возможность обработать запрос более чем одному объекту.
Связывает объекты-получатели и передает запрос по цепочке, пока объект не
обработает его.
\end{itemize}

Графы моделей шаблонов представлены в приложении~Е.

\section{Поиск шаблонов проектирования в существующих программах}

\subsection{Проект <<java-design-patterns>>}

Проект находится в открытом доступе, размещен на ресурсе
github.com~\cite{java-design-patterns}.
Интересен тем, что содержит сборник из 48 примеров реализации различных
шаблонов проектирования на языке \textbf{Java},
что очень хорошо подходит для проверки работы программного комплекса.
Здесь можно увидеть некоторые из особенностей реализации шабонов,
поэксперементировать с разными представлениями шаблона.

\subsubsection*{Поиск шаблона <<абстрактная фабрика>>}

Первый реализованный пример шаблона в проекте.
Реализация совпадает с разными описаниями.
Шаблон находится, результат представлен на рисунке~\ref{fig:java-design-patterns-abstract-factory}.

\begin{figure}[!ht]
\centering
\includegraphics[width=\textwidth]{inc/java-design-patterns-adapter.pdf}
\caption{Результат поиска шаблона проектирования <<абстрактная фабрика>> в примере его реализации}
\label{fig:java-design-patterns-abstract-factory}
\end{figure}

\subsubsection*{Поиск шаблона <<адаптер>>}

Для шаблона есть пример, и шаблон в нем находится.
Результат представлен на рисунке~\ref{fig:java-design-patterns-adapter}

\begin{figure}[!ht]
\centering
\includegraphics[width=\textwidth]{inc/java-design-patterns-adapter.pdf}
\caption{Результат поиска шаблона проектирования <<адаптер>> в примере его реализации}
\label{fig:java-design-patterns-adapter}
\end{figure}

\subsubsection*{Поиск шаблона <<мост>>}

В примере реализации не найден, но найден в других примерах.
Проблема заключается в том, что используется дополнительное обобщение,
чтобы не было дублирования кода.
Класс \textbf{Abstraction} разделен на две части: базовый абстрактный класс
\textbf{MagicWeapon},
который совязан ассоциацией с \textbf{MagicWeaponImp},
являющимся интерфейсом \textbf{Implementor};
и конкретными реализацими: \textbf{BlindingMagicWeapon},
\textbf{FlyingMagicWeapon}, \textbf{SoulEatingMagicWeapon}.
Здесь требуется механизм, который позволит описать класс так,
все ассоциации базового класса также являются и ассоциациями производного.
Нужна сущность, которая может объединять иерархии наследования классов в
некоторый надкласс.
UML-диаграммы классов не предоставляют такого механизма.
В данной работе эта проблема осталась не решенной.

Шаблон был найден в следующих примерах:
\begin{itemize}
\item adapter;
\item decorator;
\item intercepting-filter;
\item mediator;
\item model-view-presenter;
\item null-object;
\item poison-pill;
\item property;
\item service-layer;
\item state;
\item strategy.
\end{itemize}

\subsubsection*{Поиск шаблона <<посетитель>>}

Шаблон реализован в специальном примере и находится.
Результат представлен на рисунке~\ref{fig:java-design-patterns-visitor}

\begin{figure}[!ht]
\centering
\includegraphics[width=\textwidth]{inc/java-design-patterns-visitor.pdf}
\caption{Результат поиска шаблона проектирования <<посетитель>> в примере его реализации}
\label{fig:java-design-patterns-visitor}
\end{figure}

\subsection{Библиотека <<Apache BCEL>>}

Исследовалась в качестве примера реального проекта.
Модель проекта в \textbf{YAML}-формате занимает 4,1 МБ.
Граф модели состоит из 7700 вершин и 52000 дуг.
Здесь были найдены шаблоны <<адаптер>> (см. рисунок~\ref{fig:apache-bcel-adapter}),
<<мост>> (см. рисунок~\ref{fig:apache-bcel-bridge}).
Другие шаблоны не найдены.

\begin{figure}[!ht]
\centering
\includegraphics[width=\textwidth]{inc/apache-bcel-adapter.pdf}
\caption{Результат поиска шаблона проектирования <<адаптер>> в <<Apache BCEL>>}
\label{fig:apache-bcel-adapter}
\end{figure}

\begin{figure}[!ht]
\centering
\includegraphics[width=\textwidth]{inc/apache-bcel-bridge.pdf}
\caption{Результат поиска шаблона проектирования <<мост>> в <<Apache BCEL>>}
\label{fig:apache-bcel-bridge}
\end{figure}

\subsection{Поиск шаблонов проектирования в других проектах}

Исследовались другие проекты, написанные на языках \textbf{Java} и один на \textbf{Scala}.
Сводные результаты по всем проектам приведены в таблице~\ref{table:other-projects}.

\begin{table}[ht!]
    \centering
    \begin{tabulary}{\textwidth}{|C|C|C|}
        \hline
        Название проекта & Язык~\quad & Найденные шаблоны проектирования \\
        \hline
        Netflix EVCacahe & Java & <<вызов переопределённого метода>>, <<мост>> \\
        \hline
        airbnb aerosolve & Java & <<вызов переопределённого метода>>, <<мост>> \\
        \hline
        java-design-patterns & Java & <<абстрактная фабрика>>, <<адаптер>>, <<мост>>, <<посетитель>>, <<вызов переопределённого метода>> \\
        \hline
        Apache BCEL & Java & <<адаптер>>, <<вызов переопределённого метода>>, <<мост>> \\
        \hline
        Apache Zookeeper & Java & <<вызов переопределённого метода>>, <<мост>> \\
        \hline
        scodec & Scala & <<вызов переопределённого метода>> \\
        \hline
    \end{tabulary}
    \caption{Результаты поиска шаблонов проектирования в различных проектах}
    \label{table:other-projects}
\end{table}

\section{Тестирование производительности}

Реализация алгоритма поиска изоморфных подграфов --- самая уязвимой с точки
зрения производительности частью программного комлекса.
Использовался язык \textbf{Python}, для которого существует ряд виртуальных
машин.
Рассмотрим некоторые из них и сравним производительность программы
\textbf{match\_pattern}.

\begin{itemize}
\item \textbf{CPython} --- написана на языке \textbf{C}.
Код программы компилируется в байт-код и интерпертируется.
\item \textbf{PyPy} --- написана на языке \textbf{Python}.
Использует технологию \textbf{JIT}-компиляции, компилируя в процессе выполнения
программы код на \textbf{Python} в машинный код.
\end{itemize}

Работу программы \textbf{match\_pattern} можно разделить на две части:
загрузка модели и поиск шаблона проектирования.
Для моделей больших проектов загрузка может занимать достаточно большое время.
Рассмотрим проект \textbf{Apache Zookeeper}. Модель состоит из 101413 элементов.
Размер \textbf{.yaml}-файла --- 33~МБ.
Результаты представлены в таблице~\ref{table:read-model}.

\begin{table}[ht!]
    \centering
    \begin{tabularx}{\textwidth}{|X|X|X|X|X|}
        \hline
        Виртуальная машина & Время чтения файла модели, с & Относительное время чтения файла модели & Используемый объем памяти, КБ & Относительный используемый объем памяти \\
        \hline
        PyPy & 26 & 1,0 & 746848 & 1,0 \\
        \hline
        CPython & 180 & 6,9 & 3078436 & 4,1 \\
        \hline
    \end{tabularx}
    \caption{Тестирование производительности чтения файла модели на различных виртуальных машинах}
    \label{table:read-model}
\end{table}

В следующем тесте в проекте <<Apache BCEL>> выполнялся поиск шаблона
проектирования <<вызов переопределённого метода>>.
Программа выполняется до нахождения первых пяти результатов.
Отладочный вывод и результат программ совпадает.
Здесь учитывалось только время поиска шаблона без загрузки модели.
Результаты представлены в таблице~\ref{table:find-pattern}.

\begin{table}[ht!]
    \centering
    \begin{tabularx}{\textwidth}{|X|X|X|X|X|}
        \hline
        Виртуальная машина & Время поиска, с & Относительное время поиска & Используемый объем памяти, КБ & Относительный используемый объем памяти \\
        \hline
        CPython & 8,6 & 1,0 & 223004 & 1,64 \\
        \hline
        PyPy & 10,3 & 1,2 & 136436 & 1,0 \\
        \hline
    \end{tabularx}
    \caption{Тестирование производительности поиска шаблона проектирования <<вызов переопределённого метода>> в <<Apache BCEL>>}
    \label{table:find-pattern}
\end{table}

\section{Выводы по результатам исследования}

Метод позволяет находить шаблоны проектирования.
<<Вызов переопределенного метода>> встречается во всех проектах.
Это одна из самых распространненых конструкций.
Имеено для этого существует разделение между интерфейсом и реализацией.
Не удивительно, что такую базовую возможность ООП используют везде.
Наиболее часто встречаются шаблоны проектирования <<адаптер>> и <<мост>>.
Можно утверждать, что модели достаточно хорошо отражают эти шаблоны, и что
они действительно используются.
Для других шаблонов можно предположить, что они предназначены для специфических задач,
которые не решались в рассматриваемых проектах.

Для программы поиска шаблонов проетирования лучше использовать виртуальную машину
\textbf{PyPy}.
Она незначительно уступает \textbf{CPython} по времени поиска, но значительно
превосходит по времени загрузки модели и более эффективно использует память.
